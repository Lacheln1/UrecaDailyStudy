{"id":"node_modules/redux/src/types/actions.ts","dependencies":[{"name":"C:\\Users\\psion\\Documents\\GitHub\\UrecaDailyStudy\\5\\0519-redux-practice\\package.json","includedInParent":true,"mtime":1747587390939},{"name":"C:\\Users\\psion\\Documents\\GitHub\\UrecaDailyStudy\\5\\0519-redux-practice\\node_modules\\redux\\package.json","includedInParent":true,"mtime":1747587390892}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"},"sourceMaps":{"js":{"version":3,"file":"actions.js","sourceRoot":"","sources":["node_modules/redux/src/types/actions.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * An *action* is a plain object that represents an intention to change the\n * state. Actions are the only way to get data into the store. Any data,\n * whether from UI events, network callbacks, or other sources such as\n * WebSockets needs to eventually be dispatched as actions.\n *\n * Actions must have a `type` field that indicates the type of action being\n * performed. Types can be defined as constants and imported from another\n * module. These must be strings, as strings are serializable.\n *\n * Other than `type`, the structure of an action object is really up to you.\n * If you're interested, check out Flux Standard Action for recommendations on\n * how actions should be constructed.\n *\n * @template T the type of the action's `type` tag.\n */\n// this needs to be a type, not an interface\n// https://github.com/microsoft/TypeScript/issues/15300\nexport type Action<T extends string = string> = {\n  type: T\n}\n\n/**\n * An Action type which accepts any other properties.\n * This is mainly for the use of the `Reducer` type.\n * This is not part of `Action` itself to prevent types that extend `Action` from\n * having an index signature.\n */\nexport interface UnknownAction extends Action {\n  // Allows any extra properties to be defined in an action.\n  [extraProps: string]: unknown\n}\n\n/**\n * An Action type which accepts any other properties.\n * This is mainly for the use of the `Reducer` type.\n * This is not part of `Action` itself to prevent types that extend `Action` from\n * having an index signature.\n * @deprecated use Action or UnknownAction instead\n */\nexport interface AnyAction extends Action {\n  // Allows any extra properties to be defined in an action.\n  [extraProps: string]: any\n}\n\n/* action creators */\n\n/**\n * An *action creator* is, quite simply, a function that creates an action. Do\n * not confuse the two termsâ€”again, an action is a payload of information, and\n * an action creator is a factory that creates an action.\n *\n * Calling an action creator only produces an action, but does not dispatch\n * it. You need to call the store's `dispatch` function to actually cause the\n * mutation. Sometimes we say *bound action creators* to mean functions that\n * call an action creator and immediately dispatch its result to a specific\n * store instance.\n *\n * If an action creator needs to read the current state, perform an API call,\n * or cause a side effect, like a routing transition, it should return an\n * async action instead of an action.\n *\n * @template A Returned action type.\n */\nexport interface ActionCreator<A, P extends any[] = any[]> {\n  (...args: P): A\n}\n\n/**\n * Object whose values are action creator functions.\n */\nexport interface ActionCreatorsMapObject<A = any, P extends any[] = any[]> {\n  [key: string]: ActionCreator<A, P>\n}\n"]}},"error":null,"hash":"ae7dc564b1229929b580afd17e9b96ed","cacheData":{"env":{}}}